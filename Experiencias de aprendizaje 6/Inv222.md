Ahora te pediré que te tomes un tiempo para analizar el código y entender su funcionamiento.

- **¿Qué hace el patrón observer en este caso?**

Observer (observador)
El patrón observer aquí es como un grupo de amigos que escuchan a quien manda las órdenes. ofApp guarda una lista de observers (las partículas) y cuando ocurre algo (se presiona una tecla) llama a notify("attract") o similar. Entonces cada partícula recibe ese mensaje en su onNotify(...) y cambia su comportamiento. En resumen: ofApp avisa; las partículas escuchan y reaccionan.

- **¿Qué hace el patrón factory en este caso?**

Factory (fábrica)
La fábrica (ParticleFactory::createParticle) es una máquina que crea partículas según un nombre ("star", "shooting_star", "planet"). Así no tienes que poner todo el código de creación cada vez: pides a la fábrica y te devuelve una Particle* ya configurada. Es práctico para crear muchos objetos parecidos con pocas líneas.

- **¿Qué hace el patrón state en este caso?**

State (estado)
El patrón state hace que cada partícula tenga un “modo” o comportamiento actual (Normal, Attract, Repel, Stop...). Cada State sabe cómo actualizar la partícula cuando está en ese modo. Si la partícula cambia de estado, se borra el viejo State y se pone uno nuevo; así el mismo objeto puede comportarse distinto sin tener if por todos lados.

Experimenta con el código y realiza algunas modificaciones para entender mejor su funcionamiento. Por ejemplo:

- **Adiciona un nuevo tipo de partícula.**

***(ParticleFactory::createParticle en ofApp.cpp):***
```cpp
else if (type == "comet") {
    particle->size = ofRandom(4, 7);
    particle->color = ofColor(200, 200, 50);
    particle->velocity *= 6.0f;
}
```
***setup():***
```cpp
Copiar código
for (int i = 0; i < 3; ++i) {
    Particle* p = ParticleFactory::createParticle("comet");
    particles.push_back(p);
    addObserver(p);
}
```

- **Adiciona un nuevo estado.**

***En el header (ofApp.h):***
```cpp
class OrbitState : public State {
public:
    void update(Particle* particle) override;
    void onEnter(Particle* particle) override;
};
```
***(ofApp.cpp):***
```cpp
void OrbitState::onEnter(Particle* particle) {
    particle->color = ofColor(150, 200, 255);
    if (particle->velocity.length() > 0.1f)
        particle->velocity = particle->velocity.getNormalized() * 0.5f;
}

void OrbitState::update(Particle* particle) {
    ofVec2f center(((ofApp*)ofGetAppPtr())->mouseX, ((ofApp*)ofGetAppPtr())->mouseY);
    ofVec2f rel = particle->position - center;
    float dist = rel.length();
    if (dist < 1) dist = 1;

    ofVec2f tangent(-rel.y, rel.x);
    tangent.normalize();
    float orbitSpeed = ofClamp(50.0f / dist, 0.2f, 3.0f);

    particle->velocity = tangent * orbitSpeed;
    particle->position += particle->velocity * 0.6f;
}
```
***Particle::onNotify:***
```cpp
else if (event == "orbit") {
    setState(new OrbitState());
}
```
***ofApp::keyPressed:***
```cpp
else if (key == 'o') {
    notify("orbit");
}
```

- **Modifica el comportamiento de las partículas.**

***corregido con cálculo de magnitud total:***
```cpp
float speed = particle->velocity.length();
float maxSpeed = 3.0f;
if (speed > maxSpeed) 
    particle->velocity = (particle->velocity / speed) * maxSpeed;
```

- **Crea otros eventos para notificar a las partículas.**

***header (ofApp.h):***
```cpp
~ofApp();
```
***.cpp:***
```cpp
ofApp::~ofApp() {
    for (Particle* p : particles) {
        removeObserver(p);
        delete p;
    }
    particles.clear();
}
```

- **Código completo modificado**

ofApp.h
```cpp
#pragma once

#include "ofMain.h"
#include <vector>
#include <string>

class Observer {
public:
    virtual void onNotify(const std::string& event) = 0;
};

class Subject {
public:
    void addObserver(Observer* observer);
    void removeObserver(Observer* observer);
protected:
    void notify(const std::string& event);
private:
    std::vector<Observer*> observers;
};

class Particle;

class State {
public:
    virtual void update(Particle* particle) = 0;
    virtual void onEnter(Particle* particle) {}
    virtual void onExit(Particle* particle) {}
    virtual ~State() = default;
};

class Particle : public Observer {
public:
    Particle();
    ~Particle();

    void update();
    void draw();
    void onNotify(const std::string& event) override;
    void setState(State* newState);

    ofVec2f position;
    ofVec2f velocity;
    float size;
    ofColor color;

private:
    State* state;
};


class NormalState : public State {
public:
    void update(Particle* particle) override;
    virtual void onEnter(Particle* particle) override;
};


class AttractState : public State {
public:
    void update(Particle* particle) override;
};

class RepelState : public State {
public:
    void update(Particle* particle) override;
};

class StopState : public State {
public:
    void update(Particle* particle) override;
};

class OrbitState : public State {
public:
    void update(Particle* particle) override;
    void onEnter(Particle* particle) override;
};

class ExplodeState : public State {
public:
    void update(Particle* particle) override;
    void onEnter(Particle* particle) override;
private:
    float life = 60.0f;
};

class ParticleFactory {
public:
    static Particle* createParticle(const std::string& type);
};

class ofApp : public ofBaseApp, public Subject {
    public:
        void setup();
        void update();
        void draw();
        void keyPressed(int key);
        ~ofApp();
private:
    std::vector<Particle*> particles;
};
```
ofApp.cpp
```cpp
#include "ofApp.h"

void Subject::addObserver(Observer* observer) {
    observers.push_back(observer);
}

void Subject::removeObserver(Observer* observer) {
    observers.erase(std::remove(observers.begin(), observers.end(), observer), observers.end());
}

void Subject::notify(const std::string& event) {
    for (Observer* observer : observers) {
        observer->onNotify(event);
    }
}

Particle::Particle() {
    position = ofVec2f(ofRandomWidth(), ofRandomHeight());
    velocity = ofVec2f(ofRandom(-0.5f, 0.5f), ofRandom(-0.5f, 0.5f));
    size = ofRandom(2, 5);
    color = ofColor(255);

    state = new NormalState();
}

Particle::~Particle() {
    delete state;
}

void Particle::setState(State* newState) {
    if (state != nullptr) {
        state->onExit(this);
        delete state;
    }
    state = newState;
    if (state != nullptr) {
        state->onEnter(this);
    }
}

void Particle::update() {
    if (state != nullptr) {
        state->update(this);
    }
    if (position.x < 0 || position.x > ofGetWidth()) velocity.x *= -1;
    if (position.y < 0 || position.y > ofGetHeight()) velocity.y *= -1;
}

void Particle::draw() {
    ofSetColor(color);
    ofDrawCircle(position, size);
}

void Particle::onNotify(const std::string& event) {
    if (event == "attract") {
        setState(new AttractState());
    }
    else if (event == "repel") {
        setState(new RepelState());
    }
    else if (event == "stop") {
        setState(new StopState());
    }
    else if (event == "normal") {
        setState(new NormalState());
    }
    else if (event == "orbit") {
        setState(new OrbitState());
    }
    else if (event == "explode") {
        setState(new ExplodeState());
    }
}

void NormalState::update(Particle* particle) {
    particle->position += particle->velocity;
}

void NormalState::onEnter(Particle* particle) {
    particle->velocity = ofVec2f(ofRandom(-0.5f, 0.5f), ofRandom(-0.5f, 0.5f));
}

void AttractState::update(Particle* particle) {
    ofVec2f mousePos(((ofApp*)ofGetAppPtr())->mouseX, ((ofApp*)ofGetAppPtr())->mouseY);
    ofVec2f dir = mousePos - particle->position;
    if (dir.length() > 0) dir.normalize();
    particle->velocity += dir * 0.05f;

    float speed = particle->velocity.length();
    float maxSpeed = 3.0f;
    if (speed > maxSpeed) particle->velocity = (particle->velocity / speed) * maxSpeed;

    particle->position += particle->velocity * 0.2f;
}

void RepelState::update(Particle* particle) {
    ofVec2f mousePos(((ofApp*)ofGetAppPtr())->mouseX, ((ofApp*)ofGetAppPtr())->mouseY);
    ofVec2f dir = particle->position - mousePos;
    if (dir.length() > 0) dir.normalize();
    particle->velocity += dir * 0.05f;

    float speed = particle->velocity.length();
    float maxSpeed = 3.0f;
    if (speed > maxSpeed) particle->velocity = (particle->velocity / speed) * maxSpeed;

    particle->position += particle->velocity * 0.2f;
}

void StopState::update(Particle* particle) {
    particle->velocity.set(0,0);
}

void OrbitState::onEnter(Particle* particle) {
    particle->color = ofColor(150, 200, 255);
    if (particle->velocity.length() > 0.1f)
        particle->velocity = particle->velocity.getNormalized() * 0.5f;
}

void OrbitState::update(Particle* particle) {
    ofVec2f center(((ofApp*)ofGetAppPtr())->mouseX, ((ofApp*)ofGetAppPtr())->mouseY);
    ofVec2f rel = particle->position - center;
    float dist = rel.length();
    if (dist < 1) dist = 1;

    ofVec2f tangent(-rel.y, rel.x);
    tangent.normalize();
    float orbitSpeed = ofClamp(50.0f / dist, 0.2f, 3.0f);

    particle->velocity = tangent * orbitSpeed;
    particle->position += particle->velocity * 0.6f;
}

void ExplodeState::onEnter(Particle* particle) {
    particle->color = ofColor::red;
    particle->velocity = ofVec2f(ofRandom(-4,4), ofRandom(-4,4));
    life = 60.0f;
}

void ExplodeState::update(Particle* particle) {
    particle->position += particle->velocity;
    particle->velocity *= 0.98f;
    life -= 1.0f;
    particle->size = ofClamp(particle->size - 0.05f, 0.5f, 100);

    if (life <= 0) {
        particle->setState(new NormalState());
    }
}

Particle* ParticleFactory::createParticle(const std::string& type) {
    Particle* particle = new Particle();

    if (type == "star") {
        particle->size = ofRandom(2, 4);
        particle->color = ofColor(255, 255, 255);
    }
    else if (type == "shooting_star") {
        particle->size = ofRandom(3, 6);
        particle->color = ofColor(0, 255, 0);
        particle->velocity *= 3;
    }
    else if (type == "planet") {
        particle->size = ofRandom(5, 8);
        particle->color = ofColor(0, 0, 255);
    }
    else if (type == "comet") {
        particle->size = ofRandom(4, 7);
        particle->color = ofColor(200, 200, 50);
        particle->velocity *= 6.0f;
    }
    return particle;
}

void ofApp::setup() {
    ofBackground(0);
    for (int i = 0; i < 100; ++i) {
        Particle* p = ParticleFactory::createParticle("star");
        particles.push_back(p);
        addObserver(p);
    }
    for (int i = 0; i < 5; ++i) {
        Particle* p = ParticleFactory::createParticle("shooting_star");
        particles.push_back(p);
        addObserver(p);
    }
    for (int i = 0; i < 10; ++i) {
        Particle* p = ParticleFactory::createParticle("planet");
        particles.push_back(p);
        addObserver(p);
    }
    for (int i = 0; i < 3; ++i) {
        Particle* p = ParticleFactory::createParticle("comet");
        particles.push_back(p);
        addObserver(p);
    }
}

void ofApp::update() {
    for (Particle* p : particles) {
        p->update();
    }
}

void ofApp::draw() {
    for (Particle* p : particles) {
        p->draw();
    }
}

void ofApp::keyPressed(int key) {
    if (key == 's') {
        notify("stop");
    }
    else if (key == 'a') {
        notify("attract");
    }
    else if (key == 'r') {
        notify("repel");
    }
    else if (key == 'n') {
        notify("normal");
    }
    else if (key == 'o') {
        notify("orbit");
    }
    else if (key == 'e') {
        notify("explode");
    }
}

ofApp::~ofApp() {
    for (Particle* p : particles) {
        removeObserver(p);
        delete p;
    }
    particles.clear();
}
```